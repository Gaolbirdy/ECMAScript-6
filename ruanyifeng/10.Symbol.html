<script>
const { log } = console;
</script>

<!-- <script>
// let s = Symbol();
// log(s);
// log(typeof s);

// let s1 = Symbol('foo');
// let s2 = Symbol('bar');
// let s3 = Symbol('bar');
// let s4 = s3;

// log(s1);
// log(s2);
// log(s3);
// log(s4);
// log(s2 == s3);
// log(s2 === s3);
// log(s3 == s4);
// log(s3 === s4);

// log(s1.toString());
// log(s2.toString());

// const obj = {
//     toString() {
//         return 'abc';
//     }
// };
// const sym = Symbol(obj);
// log(sym);

// let s1 = Symbol();
// let s2 = Symbol();
// log(s1 === s2);

// let s1 = Symbol('foo');
// let s2 = Symbol('foo');
// log(s1 === s2);

// let sym = Symbol('My symbol');

// // log('your symbol is ' + sym);
// // log(`your symbol is ${sym}`);

// log(String(sym));
// log(sym.toString());

let sym = Symbol();
// log(Boolean(sym));
// log(Boolean(!sym));
// if (sym) {
//     log(true);
// }

// Number(sym);
log(sym + 2);
</script> -->

<!-- <script>
// let mySymbol = Symbol();

// // let a = {};
// // a[mySymbol] = 'Hello!';

// // let a = {
// //     [mySymbol]: 'Hello'
// // };

// let a = {};
// Object.defineProperty(a, mySymbol, {value: 'Hello!'});

// log(a[mySymbol]);


// a.mySymbol = 'Hello!';
// log(a.mySymbol);
// log(a['mySymbol']);
// log(a.mySymbol === a['mySymbol']);

// const mySymbol = Symbol();
// const a = {};
// a.mySymbol = 'hello';
// log(a[mySymbol]);
// log(a['mySymbol']);

// let s = Symbol();
// let obj = {
//     [s]: function (arg) {log(arg);}
// };
// obj[s](123);

// let obj = {
//     [s](arg) {}
// };

// const l = {};

// l.levels = {
//     DEBUG: Symbol('debug'),
//     INFO: Symbol('info'),
//     WARN: Symbol('warn'),
// };

// log(l);
// log(l.levels.DEBUG, 'debug message');
// log(l.levels.INFO, 'info message');

const COLOR_RED = Symbol();
const COLOR_GREEN = Symbol();

function getComplement(color) {
    switch (color) {
        case COLOR_RED:
            return COLOR_GREEN;
        case COLOR_GREEN:
            return COLOR_RED;
        default:
            throw new Error('Undefined color');
    }
}

</script> -->

<!-- <script>
// function getArea(shape, options){
//     let area = 0;

//     switch (shape) {
//         case 'Triangle':
//             area = .5 * options.width * options.height;
//             break;
//         default:
//             break;
//     }

//     return area;
// }

// getArea('Triangle', { width: 100, height: 100});

const shapeType = {
    // triangle: 'Triangle'
    triangle: Symbol()
};

function getArea(shape, options) {
    let area = 0;
    switch (shape) {
        case shapeType.triangle:
            area = .5 * options.width * options.height;            
            break;
    }
    return area;
}

log(getArea(shapeType.triangle, { width: 100, height: 100}));
</script> -->

<!-- <script>
// const obj = {};
// let a = Symbol('a');
// let b = Symbol('b');

// obj[a] = 'hello';
// obj[b] = 'world';

// const objectSymbols = Object.getOwnPropertySymbols(obj);
// log(objectSymbols);

// const obj = {};

// let foo = Symbol('foo');

// Object.defineProperty(obj, foo, {value: 'foobar'});

// for(let i in obj){
//     log(i);
// }

// log(Object.getOwnPropertyNames(obj));

// log(Object.getOwnPropertySymbols(obj));


// let obj = {
//     [Symbol('my_key')]: 1,
//     enum: 2,
//     nonEnum: 3
// };

// log(Reflect.ownKeys(obj));

let size = Symbol('size');

class Collection {
    constructor() {
        this[size] = 0;
    }

    add(item) {
        this[this[size]] = item;
        this[size]++;
    }

    static sizeof(instance) {
        return instance[size];
    }

    sizeof() {
        return this[size];
    }
}

let x = new Collection();
log(x[size]);
log(Collection.sizeof(x));
log(x.sizeof());

x.add('foo');
log(x[size]);
log(Collection.sizeof(x));
log(x.sizeof());
log(x['0']);
log(x[0]);

log(Object.keys(x));
log(Object.getOwnPropertyNames(x));
log(Object.getOwnPropertySymbols(x));

</script> -->

<!-- <script>
// let s1 = Symbol('foo');
// let s2 = Symbol('foo');
// log(s1 === s2);

// let s1 = Symbol.for('foo');
// let s2 = Symbol.for('foo');
// log(s1 === s2);

// let s1 = Symbol('foo');
// let s2 = Symbol.for('foo');
// log(s1 === s2);

// log(Symbol.for('bar') === Symbol.for('bar'));
// log(Symbol('bar') === Symbol('bar'));

// let s1 = Symbol.for('foo')
// log(Symbol.keyFor(s1));
// log(Symbol.keyFor(Symbol.for('foo')));

// let s2 = Symbol('foo');
// log(Symbol.keyFor(s2));

iframe = document.createElement('iframe');
iframe.src = String(window.location);
document.body.appendChild(iframe);

iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo');

</script> -->

<script>
// class MyClass {
//     f (foo) {
//         return foo instanceof Array;
//     }
// }
// log(new MyClass().f([1,2,3]));

// class MyClass {
//     [Symbol.hasInstance](foo) {
//         return foo instanceof Array;
//     }
// }

// log([1, 2, 3] instanceof new MyClass());
// // log(new MyClass()[Symbol.hasInstance]([1, 2, 3]));

// class Even {
//     static [Symbol.hasInstance](obj) {
//         return Number(obj) % 2 === 0;
//     }
// }

// log(1 instanceof Even);
// log(2 instanceof Even);
// log('2' instanceof Even);
// log('adsf' instanceof Even);
// log('' instanceof Even);

// const Odd = {
//     [Symbol.hasInstance](obj) {
//         return !isNaN(obj) && Number(obj) % 2 !== 0;
//     }
// };

// log(1 instanceof Odd);
// log(2 instanceof Odd);
// log('2' instanceof Odd);
// log('adsf' instanceof Odd);
// log('' instanceof Odd);

// log(NaN === NaN);
// log(NaN == NaN);

// let arr1 = ['c', 'd'];
// log(['a', 'b'].concat(arr1, 'e'));
// log(typeof arr1);
// log(arr1[Symbol.isConcatSpreadable]);

// let arr2 = ['c', 'd'];
// arr2[Symbol.isConcatSpreadable] = false;
// log(['a', 'b'].concat(arr2, 'e'));

// let obj = {length: 2, 0: 'c', 1: 'd'};
// log(['a', 'b'].concat(obj, 'e'));

// obj[Symbol.isConcatSpreadable] = true;
// log(['a', 'b'].concat(obj, 'e'));

// class A1 extends Array {
//     constructor(args) {
//         super(args);
//         this[Symbol.isConcatSpreadable] = true;
//     }
// }

// class A2 extends Array {
//     constructor(args) {
//         super(args);
//     }
//     get [Symbol.isConcatSpreadable] () {
//         return false;
//     }
// }

// let a1 = new A1();
// a1[0] = 3;
// a1[1] = 4;

// let a2 = new A2();
// a2[0] = 5;
// a2[1] = 6;
// log([1, 2].concat(a1).concat(a2));

// class MyArray extends Array {
//     static get [Symbol.species] () {return Array;}

//     // static get [Symbol.species] () {
//     //     return this;
//     // }
// }

// const a = new MyArray(1, 2, 3);
// const b = a.map(x => x + 1);
// const c = a.filter(x => x > 1);
// log(b);
// log(c);
// log(b instanceof MyArray);
// log(b instanceof Array);
// log(c instanceof MyArray);
// log(c instanceof Array);

// class T1 extends Promise {

// }

// class T2 extends Promise {
//     static get [Symbol.species] () {
//         return Promise;
//     }
// }

// log(new T1(r => r()).then(v => v) instanceof T1);
// log(new T2(r => r()).then(v => v) instanceof T2);

// class MyMatcher {
//     [Symbol.match](string) {
//         return 'hello world'.indexOf(string);
//     }
// }

// log('e'.match(new MyMatcher())); 


// const x = {};
// x[Symbol.replace] = (...s) => console.log(s);

// 'Hello'.replace(x, 'World');

// class MySearch {
//     constructor(value) {
//         this.value = value;
//     }
//     [Symbol.search](string) {
//         return string.indexOf(this.value);
//     }
// }
// log('foobar'.search(new MySearch('oo')));

// class MySplitter {
//     constructor(value) {
//         this.value = value;
//     }
//     [Symbol.split](string) {
//         let index = string.indexOf(this.value);
//         if(index === -1){
//             return string;
//         }
//         return [
//             string.substr(0, index),
//             string.substr(index + this.value.length)
//         ];
//     }
// }

// log('foobar'.split(new MySplitter('foo')));
// log('foobar'.split(new MySplitter('bar')));
// log('foobar'.split(new MySplitter('baz')));
// log('foobar'.split(new MySplitter('ob')));

// const myIterable = {};
// myIterable[Symbol.iterator] = function* () {
//     yield 1;
//     yield 2;
//     yield 3;
// }

// log([...myIterable]);

// class Collection {
//     *[Symbol.iterator]() {
//         let i = 0;
//         while(this[i] !== undefined){
//             yield this[i];
//             ++i;
//         }
//     }
// }

// let myCollection = new Collection();
// myCollection[0] = 1;
// myCollection[1] = 2;

// for(let value of myCollection){
//     log(value);
// }

// let obj = {
//     [Symbol.toPrimitive](hint) {
//         switch (hint) {
//             case 'number':
//                 return 123;
//             case 'string':
//                 return 'str';
//             case 'default':
//                 return 'default';
//             default:
//                 throw new Error();
//         }
//     }
// };

// log(2 * obj);
// log(3 + obj);
// log(obj == 'default');
// log(obj === 'default');
// log(String(obj));


// log(({[Symbol.toStringTag]: 'foo'}.toString()));
// log(({}.toString()));

// class Collection {
//     get [Symbol.toStringTag]() {
//         return 'xxx';
//     }
// }

// let x = new Collection();
// log(Object.prototype.toString.call(x));
// log(Object.toString(x));

// log(Object.keys(Array.prototype[Symbol.unscopables]));
// log(Array.prototype[Symbol.unscopables]);

// class MyClass {
//     foo() { return 1;}
//     bar() { return 100;}
// }

// var foo = function () { return 2;};

// with (MyClass.prototype) {
//     log(foo());
//     log(bar());
// }

class MyClass {
    foo() { return 1;}
    bar() { return 100;}
    get [Symbol.unscopables] () {
        return { foo: true, bar: false};
    }
}

var foo = function () { return 2;};
var bar = function () { return 200;};

with (MyClass.prototype) {
    log(foo());
    log(bar());
}

</script>